% !TeX root = ../main.tex
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Language
\chapter{Specification Language for Robotics Properties}
\label{chap:language}

In this chapter, the structure and intricacies of the DSL are presented. The notations used in the DSL, like concepts and keywords, are introduced in (\autoref{sec:languagenotations}). The DSL grammar is written in the Backus-Naur Form (\autoref{sec:grammar}). Finally, some practical examples are written with the help of the DSL to display its expressiveness (\autoref{sec:languageexamples}).


% ------------------------------------------------------------------------------
% Language Notations
\section{Language Notations}
\label{sec:languagenotations}

The high-level concepts that can be created in the language are:

\begin{itemize}
\item \textbf{Property -} A property represents a temporal specification or a blend of temporal specifications between components.
\item \textbf{Declaration -} A declaration allows for the representation of ROS \textit{topics} in order to interact with it.
\item \textbf{Model -} A model allows for the declaration of specific \textit{topics} that are required when correlating certain robots' and simulation components.
\item \textbf{Association -} An association serves as a way to create program variables.
\end{itemize}


% ------------------------------------------------------------------------------
% Temporal Keywords
\subsection{Temporal Keywords}
\label{ssec:tempkeywords}

We consider not only LTL basic operators but also some common shortcuts for useful combinations of such operators, like \textit{after\_until}.

\begin{itemize}
\item {\bfseries always X} - X has to hold on the entire subsequent path;
\item {\bfseries never X} - X never holds on the entire subsequent path;
\item {\bfseries eventually X} - X eventually has to hold somewhere on the subsequent path;
\item {\bfseries after X, Y} - after the event X is observed, Y has to hold on the entire subsequent path;
\item {\bfseries until X, Y} - X holds at the current or future position, and Y has to hold until that position. At that position, Y does not have to hold anymore;
\item {\bfseries after\_until X, Y, Z} - after the event X is observed, Z has to hold on the entire subsequent path up until Y happens. At that position, Z does not have to hold anymore;
\end{itemize}


% ------------------------------------------------------------------------------
% Temporal value
\subsection{Temporal value}
\label{ssec:tempvalues}

It is also possible to reference previous variable states:
\begin{equation}
@\{X, -y\}
\end{equation}
This will represent the value of the variable X in the point in time -y.


% ------------------------------------------------------------------------------
% Functions
\subsection{Simulation primivitives}
\label{ssec:simprimitives}

To support comparing the internal state of the robotic system with the environment, we provide basic primitives in the language to refer to the simulation environment:

\begin{itemize}
\item {\bfseries X.position} - The position of the robot in the simulation;
\item {\bfseries X.position.y} - The position in the y axis of the robot in the simulation. Also works for x and z;
\item {\bfseries X.distance.Y} - The absolute distance between two objects in the simulation. For the x and y axis;
\item {\bfseries X.distanceZ.Y} - The absolute distance between two objects in the simulation. For the x, y, and z axis;
\item {\bfseries X.velocity} - The velocity of an object in the simulation. This refers to linear velocity;
\item {\bfseries X.velocity.x} - The velocity in the x axis of an object in the simulation. This refers to linear velocity;
\item {\bfseries X.localization\_error} - The difference between the robot's perception of its position and the actual position in the simulation;
\end{itemize}


% ------------------------------------------------------------------------------
% Operands
\subsection{Operands}
\label{ssec:operands}

Besides the already mentioned operands, \textit{Temporal values}, \textit{Simulation primivitives}, and \textit{Temporal Keywords}, the DSL also supports both Integer and Float values, Booleans, and declared variables.


% ------------------------------------------------------------------------------
% Operators
\subsection{Operators}
\label{ssec:operators}

The DSL supports operators to correlate components. The operators are \textit{+} (addition), \textit{-} (subtraction), \textit{*} (multiplication), \textit{/} (division), \textit{==} (equals), \textit{!=} (different), \textit{>} (greater than), \textit{>=} (greater or equal than), \textit{<} (lower than), \textit{<=} (lower or equal than), \textit{and} (conjunction), \textit{or} (disjunction), \textit{implies} (implication), and for any comparison operator X \textit{X{y}} - the values being compared will have an error margin of y (Example: Z =={0.05} Y).


% ------------------------------------------------------------------------------
% Protected Variables
\subsection{Protected Variables}
\label{ssec:protectedvariables}

Protected variables are variable names restricted to set determined monitoring parameters.

\_rate\_ - Set the frame rate which properties are checked (By default, the rate is 30hz)

\_timeout\_ - Set the timeout for how long the verification will last (By default, the timeout is 100 seconds)

\_margin\_ - Set the error margin for comparisons


% ------------------------------------------------------------------------------
% Topic declaration
\subsection{Topic declaration}
\label{ssec:declarations}

In order to relate robot components with the simulation, the developer can declare the relevant \textit{topics}.

The language cannot inherently have a way to interact with specific components of a robot because it does not know which topic to get information from. Therefore, the developer needs to declare these specific topics to be able to interact with them.

\textit{The variable robot\_position was declared with the type Odometry.pose.pose.position and is linked to the topic /odom;}

\texttt{decl robot\_position /odom Odometry.pose.pose.position}


% ------------------------------------------------------------------------------
% Model robots
\subsection{Model robots}
\label{ssec:models}

A set of specific topics can be modeled for the robot, like \textit{position} or \textit{velocity}. The compiler will use these to call specific functions that need this information from the robot's perspective.

\texttt{model robot1:}

\texttt{    position /odom Odometry.pose.pose.position}

\texttt{    ;}

\texttt{never robot1.localization error > 0.002}


% ------------------------------------------------------------------------------
% Grammar
\section{Grammar}
\label{sec:grammar}

\begin{bnfgrammar}
    <program> %: Start
    ::=
    <command> || <command> <program>
    ;;
    <command> ::=
    <association>
    || <declaration>
    || <model>
    || <pattern>
    ;; 
    <association> ::=
    name = <pattern>
    | \_rate\_ = integer
    | \_timeout\_ = <number>
    | \_default\_margin\_ = <number>
    ;;
    <declaration> ::=
    decl name topic\_name <msgtype>
    | decl name name <msgtype>
    ;;
    <model> ::= 
    model name $\colon$ <modelargs> ;
    ;;
    <modelargs> ::= 
    <name> topic\_name <msgtype>
    | <name> <name> <msgtype>
    | <name> topic\_name <msgtype> <modelargs>
    | <name> <name> <msgtype> <modelargs>
    ;;
    <name> ::= 
    name || <func\_main>
    ;;
    <func\_main> ::= 
    position
    || velocity
    || distance
    || localization\_error
    || orientation
    ;;
    <msgtype> ::= 
    <name> || <name> . <msgtype>
    ;;
    <pattern> ::= 
    always <pattern>
    | never <pattern>
    | eventually <pattern>
    | after <pattern> , <pattern>
    | until <pattern> , <pattern>
    | after\_until <pattern> , <pattern> , <pattern>
    | <conjunction>
    ;;
    <conjunction> ::= 
    <conjunction> and <comparison>
    | <conjunction> or <comparison>
    | <conjunction> implies <comparison>
    | <comparison>
    ;;
    <comparison> ::= 
    <multiplication> <opbin> <multiplication>
    | <multiplication> <opbin> { <number> } <multiplication>
    | <multiplication>
    ;;
    <opbin> ::= 
    < || > || <= || >= || == || !=
    ;;
    <multiplication> ::= 
    <multiplication> * <addition>
    | <multiplication> / <addition>
    | <addition>
    ;;
    <addition> ::= <addition> + <operand>
    || <addition> - <operand>
    || <operand>
    ;;
    <operand> ::= 
    name | <number> | true | false | <func> | <temporalvalue> | ( <pattern> )
    ;;
    <number> ::= 
    float || integer
    ;;
    <func> ::= 
    name . <func\_main>
    || name . <func\_main> <funcargs>
    ;;
    <funcargs> ::= 
    . <name> || . <name> <funcargs>
    ;;
    <temporalvalue> ::= 
    @ { name , integer }
\end{bnfgrammar}


% ------------------------------------------------------------------------------
% DSL Usage Examples
\section{DSL Usage Examples}
\label{sec:languageexamples}
To validate the expressive power of our language, we present examples of expressions inspired by real-world scenarios.


% ------------------------------------------------------------------------------
% Vehicle Maximum Speed
\subsection{Vehicle Maximum Speed}
\label{sec:speedexample}

Some robots have a maximum safe speed at which they can move. Sometimes this limit is imposed by law, but some other times by physical constraints.

\textit{The robot velocity will never be above 2 for the duration of the simulation;}

\texttt{never robot.velocity > 2.0}


% ------------------------------------------------------------------------------
% Follow the Leader
\subsection{Follow the Leader}
\label{ssec:followexample}

The first robot being above 1 velocity implies that the second robot is at least at 0.8 distance from the first robot. Up until the first robot reaches a particular location;

\texttt{until (robot1.position.x > 45 and robot1.position.y > 45), always (robot1.velocity > 1 implies robot2.distance.robot1 > 0.8)}


% ------------------------------------------------------------------------------
% Localization error
\subsection{Localization error}
\label{ssec:localizationexample}

The localization error (difference between the robot's perception of its location and the actual simulation location) of the robot is never above a specific value.

\texttt{model robot1:}

\texttt{    position /odom Odometry.pose.pose.position}

\texttt{    ;}

\texttt{never robot1.localization error > 0.002}


% ------------------------------------------------------------------------------
% Drone height rotors control
\subsection{Drone height rotors control}
\label{ssec:rotorsexample}

After a drone is at a certain altitude, both rotors always have the same velocity up until the drone decreases to a certain altitude.

\texttt{decl rotor1\_vel /drone\_mov/rotor1 Vector3.linear.x}

\texttt{decl rotor2\_vel /drone\_mov/rotor2 Vector3.linear.x}

\texttt{after\_until drone.position.z > 5, drone.position.z < 5, rotor1\_vel == rotor2\_vel}
