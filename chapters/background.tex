% !TeX root = ../main.tex
\chapter{Background \& Related Work}
\label{chap:background}

This chapter gives an overview of the background software adopted while developing this work (\autoref{sec:background}), and shines light on the already existing similar work and adopted techniques on the subject (\autoref{sec:relatedwork}).


% ------------------------------------------------------------------------------
% Background
\section{Background}
\label{sec:background}

This section provides some background on the used software and the reason for its choice, what the Robot Operating System is (\autoref{ssec:ros}), and the simulation software adopted (\autoref{ssec:gazebo}).


% ------------------------------------------------------------------------------
% ROS
\subsection{Robot Operating System}
\label{ssec:ros}

The Robot Operating System (ROS)~\cite{quigley2009ros} is an open-source framework with a vast collection of libraries, interfaces, and tools designed to help build robot software. ROS provides an abstraction between hardware and software that helps developers easily connect the different robot components predominantly through messages sent through communication channels called \textit{topics} via a publish-subscribe architecture.

ROS has a modular architecture and other advantages built with the purpose of cross-collaboration and easy development~\cite{ros-industrial}. For all these reasons, ROS is used by hundreds of companies and research labs.

The ROS ecosystem is built so that the majority of the projects depend on a specific set of packages.
\chris{This definitely isn't intentional! ROS has just ended up with a very strong \enquote{standard library} of packages that are used by almost everyone, and a large number of packages that don't belong to that standard library that are rarely used by anyone.
This is generally seen as a bad thing in software ecosystems, but for this work (and QA generally), it's actually good!
You can specify the behavior of a smaller standard library and still be able to represent the behavior of a large number of ROS systems.}
Literature states that around eighty-two percent of ROS applications rely on packages released by a small subset of groups~\cite{9240632}.


% ------------------------------------------------------------------------------
% Gazebo
\subsection{Gazebo}
\label{ssec:gazebo}

Robotic systems simulation is an essential tool for testing robots' behavior. For this reason, Gazebo~\cite{koenig2004design} started with the idea of a high-fidelity simulator to simulate robots in any environment under mixed conditions.

Gazebo is an open-source 3D simulator that supports tools like sensors simulation, mesh management, and actuators control under different physics engines, among others, which makes it a simulator that very distinct robotic systems can use.


% ------------------------------------------------------------------------------
% Related Work
\section{Related Work}
\label{sec:relatedwork}

This section shows some research on runtime testing, the different techniques, and the difficulties of implementing it that already exist (\autoref{ssec:runtimetesting}). The importance of Invariant specification and its relation to Linear Temporal Logic (LTL) (\autoref{ssec:ltlinvariants}). In the end, some monitoring frameworks have already tried to implement similar runtime verification concepts (\autoref{ssec:monitoringframeworks}).


% ------------------------------------------------------------------------------
% Runtime Monitoring
\subsection{Runtime Testing}
\label{ssec:runtimetesting}

\chris{What is runtime testing/monitoring? It should be defined here.}
Due to the mentioned unforeseen circumstances when executing robotic systems, runtime testing, although sometimes time-consuming, may be advantageous when identifying errors in these types of systems.

Implementing runtime monitoring adds load to the simulation. Therefore, not demanding excessive resources is essential when taking this approach.

Some challenges in implementing such mechanisms are mentioned in the cited paper~\cite{stadler2022towards}.

Besides the method of monitoring chosen in this work, runtime testing can be implemented in other ways. For instance, Mithra~\cite{AfzalMithra} is a tool that provides an oracle for automated simulation-based testing relying on machine learning software, more specifically, a three-step multivariate time series clustering.


% ------------------------------------------------------------------------------
% Linear Temporal Logic and Invariants
\subsection{Linear Temporal Logic and Invariants}
\label{ssec:ltlinvariants}

An invariant represents a property that holds through the execution of the system. Having a set of invariants for a robotic system and asserting them at runtime makes it able to prove the correctness of the system.

Research on invariant checking~\cite{zizyte2021importance} demonstrates that important safety bugs in real-world autonomous robotic systems can be identified when representing safety violations of systems and monitoring them.

Linear temporal logic (LTL) is a branch of logic responsible for representing and reasoning about modalities in reference to time. 

As an approach for program verification, a formal system of temporal logic was suggested for both sequential and parallel programs~\cite{pnueli1977temporal}. LTL can be used as a method of model-checking~\cite{dwyer1998property} using its patterns as a form of property specification. It includes patterns such as "always", "finally", "until", "eventually", and others, which can be useful in the creation of invariants for program verification of robotics systems.


% ------------------------------------------------------------------------------
% Monitoring Frameworks
\subsection{Monitoring Frameworks}
\label{ssec:monitoringframeworks}

Similar work on runtime monitoring that integrates with ROS already exists. 

ROSMonitoring~\cite{ferrando2020rosmonitoring} can monitor and log errors at the level of \textit{topic} malfunctioning, but it seems unable to express more high-level properties, which is the objective of this work. \af{What are the high-level properties? Can you describe the difference? Or at least give examples of things that are not possible?}

ROSRV~\cite{huang2014rosrv} although able to express more high-level specifications, it is highly complex and, in some way, hard for non-expert users to work with. An intuitive domain-specific language will allow a broader set of users to specify a robotic system's properties. \af{Why is it hard for non-experts? This needs to be explained!}

\af{Para cada uma destas ferramentas tens de ir com muito mais detalhe a dizer o que fazem, como funcionam e quais (e porque das) as suas limitações!. }